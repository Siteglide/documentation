# Live Updates Reference

### Including JS <a href="#html-dataattribute-markup" id="html-dataattribute-markup"></a>

```liquid
{% if context.exports.sitebuilder.live_update_JS_loaded == blank %}
  <script async src="{{'modules/module_86/js/v1-6/sitegurus_live_update_javascript_api.js' | asset_url }}"></script>
  {% assign live_update_JS_loaded = true %}
  {% export live_update_JS_loaded, namespace: sitebuilder %}
{% endif %}
```

### HTML data-attribute markup <a href="#html-dataattribute-markup" id="html-dataattribute-markup"></a>

HTML data-attributes are a convenient way to configure the Live Update API JavaScript. We recommend using these in most use-cases. Unlike some JavaScript Libraries, it is possible to use data-attributes along with JavaScript methods without any known conflicts.

<table data-full-width="true"><thead><tr><th>Attribute</th><th>Role</th><th>Required</th><th>Example</th><th></th></tr></thead><tbody><tr><td>`data-sg-live-update-section`</td><td>Allows you to pass a uniq reference to the Object which will allow you to access it later in the `window.sgLiveUpdateConfig` object (when ready - see Events).</td><td>Optional</td><td>`&#x3C;section data-sg-live-update-section="uniq">&#x3C;/section>`</td><td></td></tr><tr><td>`data-sg-live-update-key`</td><td>Passes the public_key to the API. You need to build the public key first using the function tag above. No other data-attributes will function without this one.</td><td>Required</td><td>`&#x3C;section data-sg-live-update-key="{{public_key}}">&#x3C;/section>`</td><td></td></tr><tr><td>`data-sg-live-update-component`</td><td>Marks this element as a live-updateable element. If at least one of these are set, the default behaviour changes from live-updating the whole layout, to only live-updating the passed components. The data-attribute in the current and live-updated DOM code must match for this to work.</td><td>Optional</td><td>`&#x3C;div data-sg-live-update-component="willChange1">&#x3C;/div>`</td><td></td></tr><tr><td>`data-sg-live-update-controls`</td><td>This marks this part of the HTML as an interactive area which should have default event listeners added.</td><td>Optional</td><td>`&#x3C;form data-sg-live-update-controls="willChange1">&#x3C;input type="text" name="foo" value="bar">`</td><td></td></tr><tr><td>`data-sg-live-update-control-group`</td><td>When adding a custom toggle button, this attribute's value should be the name of a group of buttons. Using the special "page" group means the button is reset to Page 1 when other changes in state occur.</td><td>Optional</td><td>`&#x3C;div data-sg-live-update-control-params="?range_gte={{month.start}}&#x26;range_lt={{month.end}}&#x26;range_type=month" data-sg-live-update-control-group="month">&#x3C;/div>`</td><td></td></tr><tr><td>`data-sg-live-update-listeners-attached`</td><td>This is added automatically when using data-attributes to indicate that event listeners have already been added to the component. It can be used to tell the API not to add any more automatic event listeners to this element. In normal use, you do not need to set it.</td><td>optional</td><td></td><td></td></tr><tr><td>`data-sg-live-update-modify-history-enabled="true"`</td><td>Turns on modifyHistory behaviour, updating the URL parameters without refreshing the page when live-update form elements are modified by the user.</td><td>optional</td><td>`&#x3C;section data-sg-live-update-section="uniq" data-sg-live-update-modify-history-enabled="true">&#x3C;/section>`</td><td></td></tr><tr><td>`data-sg-live-update-modify-history-include-hidden-fields="true"`</td><td>When modifyHistory behaviour is turned on, if false, hidden live-update fields will not be included in URL history updates.</td><td>optional</td><td>`&#x3C;section data-sg-live-update-section="uniq" data-sg-live-update-modify-history-enabled="true" data-sg-live-update-modify-history-include-hidden-fields="false">&#x3C;/section>`</td><td></td></tr><tr><td>`data-sg-live-update-default-param`</td><td>This attribute should be given to an HTML form element within a `data-sg-live-update-controls` element. As usual, the element must also have a name to define which parameter it will set. This element will now set a defaultParams property instead of directly setting a parameter. This is useful because you can use the new default elements to set a default then use ordinary elements to override that default when the user makes a change. In the example here, the default parameter will be "1" until the checkbox is checked, when the parameter will be set to "2". If the checkbox is unchecked, the parameter will return to "1" instead of being removed.</td><td>optional</td><td><p>```liquid &#x3C;form sg-live-update-controls="defaults"> &#x3C;input type="hidden" data-sg-live-update-default-param name="category" value="1"> &#x3C;input type="checkbox" name="category" value="2"> &#x3C;/form></p><pre class="language-</td></tr></tbody></table>"><code class="lang-</td></tr></tbody></table>">
### GET URL Parameters &#x3C;a href="#get-url-parameters" id="get-url-parameters">&#x3C;/a>

The Live Updates API, at its core, sends requests to the server to fetch a new version of the HTML content. Therefore, this section shows you which parameters can be sent in this request to modify how the Liquid will be rendered in the next response.

Before reading this section, it will help to be familiar with the Siteglide documentation relating to the kind of Liquid tag you are intending to live-update- here are a few useful links, but you may need to browse further to find the feature you're working with:

* [WebApp List Layouts Parameters](../../../webapps/layouts/webapp-list-layout.md)
* [Parameters for Filtering](../../../webapps/layouts/searching-advanced-filtering.md)
* [Parameters for Search](../../../webapps/layouts/searching-by-keyword.md)
* [Blog Archive](../../../modules/core-modules/blog-and-authors/blog-filter-by-date.md)

On the endpoint page we provide, the Liquid tag being live-updated is output.

In order to make the process of dynamically modifying the output simpler, we are basing the parameters for modifying it 99% on existing Siteglide functionality. We will update this module after new Siteglide functionality is released. We do have a few custom parameters with an `sg` prefix which can be used to modify module behaviour.

\*\*While in Siteglide some parameters must be set via Liquid e.g. `item_ids`:

```liquid
{% include 'webapp', id: '1', layout: 'default', item_ids: '1,2' %}





</code></pre><p>...and others via URL e.g. <code>page</code>:</p><pre class="language-liquid"><code class="lang-liquid">&#x3C;!-- URL: /webapp_1?page=2 -->
{% include 'webapp', id: '1', layout: 'default' %}

</code></pre><p>...when using the Live Updates API, you can set any parameter via our URL parameters alone, giving you direct and consistent control.</p><table data-full-width="true"><thead><tr><th>parameter</th><th>notes</th></tr></thead><tbody><tr><td>`item_ids`</td><td>If using data-attributes, we'll automatically send these in comma-seperated format.</td></tr><tr><td>`category_ids`</td><td>If using data-attributes, we'll automatically send these in comma-seperated format.</td></tr><tr><td>`show_all_sub_items`</td><td></td></tr><tr><td>`per_page`</td><td></td></tr><tr><td>`show_pagination`</td><td></td></tr><tr><td>`ignore_pagination`</td><td></td></tr><tr><td>`sort_type`</td><td></td></tr><tr><td>`sort_order`</td><td></td></tr><tr><td>`type`</td><td></td></tr><tr><td>`pagination_layout`</td><td></td></tr><tr><td>`datasource`</td><td></td></tr><tr><td>`datasource_fields_by_name`</td><td></td></tr><tr><td>`datasource_fields_by_id`</td><td></td></tr><tr><td>`collection`</td><td>This parameter will only work if `collection: 'true'` is also set on the public_key generating Liquid function tag; this is to prevent malicious users from being allowed to access raw data by default, without the layer of the server defining what they should and should not access. Note however that if you do allow this, the data will be viewable in the browser, so it must not be sensitive. If set to 'true' instead of returning HTML, we'll return the raw data from the collection. The data will be available in the details of the `live_update_end` custom event on the initiated element and in the parameters of the `onAfterLiveUpdate` callback function. The DOM will not be directly modified.</td></tr><tr><td>`creator_id`</td><td>If your users have permission to access webapp/ module items they did not personally create on the Front End, you can use this parameter dynamically as normal to filter. However, if you are using this parameter to prevent users from accessing items which do not belong to them and do not wish them to be able to change this in client-side code, you can make this a sensitive parameter by adding the same parameter to the `live_update_params_encode` function. If set against the function, the parameter can't be overridden.</td></tr><tr><td>`page`</td><td></td></tr><tr><td>`use_default_properties`</td><td></td></tr><tr><td>`range_field`</td><td>Coming soon in 4.8.2</td></tr><tr><td>`range_lt`</td><td></td></tr><tr><td>`range_lte`</td><td></td></tr><tr><td>`range_gt`</td><td></td></tr><tr><td>`range_gte`</td><td></td></tr><tr><td>`use_location_search`</td><td>Unlike `use_search` and `use_adv_search`, this is not set to `'true'` by default and must be set by the developer.</td></tr><tr><td>`longlat`</td><td></td></tr><tr><td>`distance`</td><td></td></tr><tr><td>`marketplace`</td><td>Required if this is a layout for a module downloaded from the Siteglide marketplace.</td></tr><tr><td>`cache`</td><td>Using this as a default parameter could significantly boost performance, but test carefully as the feature is presently in beta.</td></tr></tbody></table><p>If you need to use a URL parameter which is missing from the table above:</p><ul><li>If Siteglide recognises it as a URL parameter which can modify results, you should be able to use it safely.</li><li>If Siteglide requires the parameter to be added as a Liquid parameter to the main tag, please ask Sitegurus and we'll add support for it, if possible.</li></ul><p><em>Live Updates Custom Parameters</em></p><p>The following parameters modify the behaviour of the API endpoint page:</p><table data-full-width="true"><thead><tr><th>parameter</th><th>notes</th></tr></thead><tbody><tr><td>`sg_skip_siteglide_constants`</td><td>Some layouts don't require the Siteglide constants tag to be rendered. You can optionally use this to skip it and improve server response time. Especiually useful if the site has a lot of categories but your layout doesn't use them.</td></tr></tbody></table><h4 id="interactive-form-areas-and-controls">Interactive Form Areas and Controls</h4><p>In the last section, we detailed the URL Parameters which the API uses to request data. This next section will detail how you can set these paramters and allow the user to interact with the HTML to change these parameters.</p><p><strong>Form Areas</strong></p><p>By interactive form areas, we mean any area of the layout which contains filters, sorting controls, pagination controls or buttons designed to change the state of the layout, causing it to live-update in some way. It will most likely have a <code>&#x3C;form></code> tag in the DOM for semantic reasons, but this is not strictly necessary.</p><p>The <code>data-sg-live-update-controls</code> attribute marks an element as an interactive form area and the JavaScript will search the area for Form elements and custom buttons to which it can attach event listeners.</p><p><strong>Using HTML Form Elements</strong></p><p>Any HTML Form elements with a name attribute (including hidden inputs) inside this element will automatically have event listeners added to them watching for "keyup" or "change" events which will trigger a live-update with new parameters based on the name and values all HTML form elements inside.</p><p>For example, the following markup can be used to add the parameters <code>&#x26;per_page=20</code> to the request URL, changing that parameter in the endpoint Liquid tag and live-updating the content with the parameter applied. The name attribute provides the parameter key and the value property provides the value:</p><pre class="language-liquid"><code class="lang-liquid">&#x3C;form sg-live-update-controls="results_per_page">
  &#x3C;select name="per_page">
    &#x3C;option value="10">10&#x3C;/option>
    &#x3C;option value="20">20&#x3C;/option>
    &#x3C;option value="50">50&#x3C;/option>
  &#x3C;/select>
&#x3C;/form>

</code></pre><p>Using the data-attributes and our automatic event listeners allows the user to modify multiple parameters at the same time. If you have filters for both category and colour, when the category filter changes, it will trigger a live-update of the content, but both the current values of the category and the colour inputs will be included in the request. Once the color filter is changed, it will in turn also include the category filter's current value in the request.</p><p>Keyup events, targeting fields in which the user will type, will be <a href="https://css-tricks.com/debouncing-throttling-explained-examples/">debounced</a> so that keyup events don't cause disorientating changes too often. After the user pauses in typing, the live-update will take the latest values and trigger the live-update. Other events are set to update immediately.</p><p><strong>Using Hidden HTML Form Elements</strong></p><p>HTML Form Elements with the <code>type="hidden"</code> attribute will behave the same as other HTML Form Elements for the purposes of controlling the GET Parameters the API will use in its requests.</p><p>One common use-case for these is to use as "default" settings that will be needed in every request, despite any choices made by the user.</p><p><strong>Live Updates Toggle Buttons</strong></p><p><em>Markup</em></p><pre class="language-liquid"><code class="lang-liquid">&#x3C;button data-sg-live-update-control-params="/blog?range_gte={{month.start}}&#x26;range_lt={{month.end}}&#x26;range_type=month" data-sg-live-update-control-group="month">{{month.start | date: "%b" }}&#x3C;/button>

</code></pre><p><em>What Problems do our custom toggle buttons solve?</em></p><p>Often in Siteglide, modules will have a single button which triggers JavaScript which will need to change multiple parameters in the URL at once, for example the archive buttons on the Blog and Events Lists needs to change both the <code>range_lt</code> and <code>range_gte</code> parameters.</p><ul><li>An ordinary form control in HTML can have only one name, so is not suitable changing multiple parameters at once without some other supporting JavaScript.</li><li>Radio buttons cannot be unchecked easily by the user. It is useful to be able to clear filters.</li></ul><p>To provide a consistent, convenient solution to both these problems, we're including custom toggle buttons in our documented markup:</p><p>Markup rules:</p><ul><li>They must use the <code>&#x3C;button></code> semantic element.</li><li>They must have a <code>data-sg-live-update-control-params</code> data-attribute. This stores an absolute or relative URL, or just the search parameters of a URL starting with a <code>?</code>. When the button is pressed, the query parameters from the passed URL will be added to the request, along with parameters sourced from other form controls.</li><li>Optionally they can have a <code>data-sg-live-update-control-group</code> data-attribute. This allows them to act as radio buttons within that group, with only one pressed at a time, however, with the important difference that it is possible to uncheck all of them. If you do not provide this attribute, the buttons will be considered to be in a group with all ungrouped buttons.</li></ul><p>When a custom toggle button is pressed, we'll automatically add the data-attribute <code>aria-pressed="true"</code> to make the toggle button match accessibility guidelines. When unpressed, we will set <code>aria-pressed</code> to false. For sighted users, we strongly recommend adding CSS to make buttons with <code>aria-pressed="true"</code> look visually as if they are toggled, for example by changing colour. e.g. in CSS:</p><pre class="language-css"><code class="lang-css">[aria-pressed=true] {
  outline-style: solid;
  outline-width: 1px;
  outline-color: #22d3ee;
}
</code></pre><p>At the time of writing, the newest version of Tailwind supports the variant <code>aria-pressed:</code>.</p><p>If using Flowbite, you can place a toggle component inside your button and modify it to use <code>group-aria-pressed:</code>; it can then show the toggled state of the parent button very clearly, using CSS only.</p><pre class="language-liquid"><code class="lang-liquid">&#x3C;button type="button" class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 mr-2 mb-2 dark:bg-blue-600 dark:hover:bg-blue-700 focus:outline-none dark:focus:ring-blue-800 group" aria-pressed="true">
  &#x3C;span class="mr-2">{{month.start | date: "%B" }}&#x3C;/span>
  &#x3C;div class="relative inline-flex items-center cursor-pointer">
    &#x3C;div class="w-11 h-6 bg-gray-200 group-focus:outline-none group-focus:ring-4 group-focus:ring-blue-300 dark:group-focus:ring-blue-800 rounded-full dark:bg-gray-700 group-aria-pressed:after:translate-x-full group-aria-pressed:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 group-aria-pressed:bg-blue-600">&#x3C;/div>
  &#x3C;/div>
&#x3C;/button>

</code></pre><p>The special group <code>data-sg-live-update-control-group="page"</code> behaves uniquely, as the page will always reset to "1" when another change is made to the parameters elsewhere. For example, if you are currently on page 2, but a filter change means there is now only one result, staying on page 2 would mean the result was hidden- the special group behaviour avoids this problem. If there is no available page 1 button, all page buttons will be unpressed.</p><p><strong>Live Updates Sort Buttons</strong></p><p>Controls to handle the sorting of module or webapp data require a slightly different approach. Such buttons commonly have three different states- unpressed, sort ascending and sort descending.</p><p>We've therefore provided specific markup for a sort button.</p><pre class="language-liquid"><code class="lang-liquid">&#x3C;div>
  Weighting
  &#x3C;button data-sg-live-update-sort-order="unsorted" data-sg-live-update-sort-type="properties.weighting" type="button" class="ml-1">
    &#x3C;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
      &#x3C;path fill-rule="evenodd" d="M2.24 6.8a.75.75 0 001.06-.04l1.95-2.1v8.59a.75.75 0 001.5 0V4.66l1.95 2.1a.75.75 0 101.1-1.02l-3.25-3.5a.75.75 0 00-1.1 0L2.2 5.74a.75.75 0 00.04 1.06zm8 6.4a.75.75 0 00-.04 1.06l3.25 3.5a.75.75 0 001.1 0l3.25-3.5a.75.75 0 10-1.1-1.02l-1.95 2.1V6.75a.75.75 0 00-1.5 0v8.59l-1.95-2.1a.75.75 0 00-1.06-.04z" clip-rule="evenodd" />
    &#x3C;/svg>
  &#x3C;/button>
&#x3C;/div>

</code></pre><p>Markup rules:</p><ul><li>They must use the <code>&#x3C;button></code> semantic element.</li><li>It is strongly recommended that the button be a child of the semantic <code>&#x3C;th></code> element.</li><li>Requires the <code>data-sg-live-update-sort-type</code> attribute to be set to the name of the field you wish to sort by. As you would on a Siteglide Liquid parameter of the same name, you need to prepend with <code>properties.</code> for any Siteglide field. platformOS core fields like id, external_id, created_at, updated_at and deleted_at do not require the properties prefix.</li></ul><ol start="4"><li>Requires the <code>data-sg-live-update-sort-order="unsorted"</code> attribute to be set. There are three available states: <code>'unsorted'</code>, <code>'asc'</code> and <code>'desc'</code>. You should set most sort controls to 'unsorted', but may set one to be sorted 'asc' or 'desc' by default. If you do sort a column 'asc' or 'desc' by default, you should add the correct <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-sort">aria-sort</a> attribute to the <code>&#x3C;th></code> ancestor element. For subsequent button interactions, our JavaScript will apply this <code>aria-sort</code> attribute for you.</li><li>In order to show changes of state in the buttons to sighted users, the buttons will change their innerHTML dynamically according to the sortHTML property of the initiated <code>SitegurusLiveUpdate</code> object. By default, the module will use a series of icons (with the default unsorted icon being used as a default state in the example below). There is no need to use icons; any HTML is valid. We'll explain how to change these defaults below the main example.</li></ol><p>When a sort button changes state to either 'asc' or 'desc', all other sort buttons will be set to 'unsorted'. The main reason for this behaviour is that sorting by multiple parameters at once is not supported by Siteglide, although it is possible via graphQL.</p><p><em>Changing default HTML for each button state</em></p><p>See the <a href="live-updates-reference.md#methods">Methods section</a> for <code>.setSortHTML();</code> and the instructions for using methods with data-attributes.</p><p><strong>Live-Updating the Interactive Form Areas</strong></p><p>Sometimes it is very convenient to make components which control live-updating, live-update themselves. A pagination <code>&#x3C;nav></code> is an excellent example, because the server can live-update this with the correct number of page buttons based on the new content.</p><p>It is not such a good idea to do this with some other form elements, like <code>&#x3C;input></code> tags, because the user will lose focus while typing and lose their progress. However, custom JavaScript may allow you to mitigate both of these problems.</p><p>When live-updating controls, here are a few general principals to improve the experience when using the API.</p><ul><li>Wrap the element which you are using to indicate the live-updated area (<code>data-sg-live-update-component</code>) around the element you are using as a form (<code>data-sg-live-update-controls</code>).</li><li><p>Make sure that the layout returns the form element no-matter what the logic, even if it is empty. Otherwise there will be an error in the console as the API tries to match up between the new content and the DOM. For example, a pagination component should return the main element even if there are no results and no pagination buttons are to be shown.</p><ul><li>This means the component must also wrap the Siteglide tag `</li></ul></li></ul><p>` as this will not render if there is no more than one page of results. * Make sure the user does not lose focus or the values of form elements they are in the middle of using.</p><hr><p><strong>Methods</strong></p><p>The following guide shows how methods can be used:</p><ul><li><a href="steps-to-use-live-updates-methods.md">Using Live Updates Methods</a></li></ul><p>The table shows available methods:</p><table data-full-width="true"><thead><tr><th>Method</th><th>Parameters</th><th>Notes</th></tr></thead><tbody><tr><td>`instance.liveUpdate(params,onBeforeLiveUpdate,onAfterLiveUpdate,changeStateOptions)`</td><td>1) `params` - Object - Pass in an object containing the key value pairs you'd like to be added to the GET request. 2) `onBeforeLiveUpdate` - Function - optional - callback function to run before update 3) `onAfterLiveUpdate` - Function - optional - Callback function to run after update. 4) See below for changeStateOptions</td><td>Params will override any default params, if they have the same key. The callback functions are especially suitable if you need any one-time side effects. If you need a callback function for every update, we recommend using events instead.</td></tr><tr><td>`instance.setSuspenseHTML('&#x3C;div>loading&#x3C;/div>')`</td><td>1) Pass in an HTML String.</td><td>We recommend using template literals. When live-updating begins, this HTML will be inserted into the area which is being live-updated. When the live-updating ends, the HTML will be replaced with the live-updated component HTML. This can also be set when using the constructor.</td></tr><tr><td>`instance.setSuspenseCSSClassList('class1 class2')`</td><td>1) ClassList space-separated</td><td>Sets CSS classes on each live-updating component and then removes them once the live-updating is complete. If no components are used, the classes are toggled on the main initiated element. As well as allowing you to change style directly, you can also use it to position suspense HTML within the container. This can also be set when using the constructor.</td></tr><tr><td>`instance.setModifyHistory({enabled: true, includeHiddenFields: false})`</td><td>1) Object</td><td>Pass in an object with an `enabled` boolean and `includehiddenFields` boolean. This changes the behaviour of each following liveUpdate so that it will update the URL query parameters without reloading the page. Useful for creating shareable links.</td></tr><tr><td>`instance.setSortHTML({unsorted: '', asc: '', desc: ''})`</td><td>1) object</td><td>Pass in an object containing an HTML string (recommend template literals) for each of the three button states.</td></tr><tr><td>`deprecated instance.setDefaultParams(object)`</td><td>1) object</td><td>Pass in an object containing the key: value pairs of parameters you wish to use as default params to fully replace existing defaultParams. Use of this is not encouraged. Use `mergeUpdateParams` instead.</td></tr><tr><td>`instance.mergeDefaultParams(object)`</td><td>1) object</td><td>Pass in an object containing the key: value pairs of parameters you wish to use as default params. This preserves any existing defaultParams, unless one of your properties matches them, in which case your property will be set.</td></tr><tr><td>`instance.changeStateTrailingDebounce(event,resetPages = false,changeStateOptions)`</td><td>1) Normally accepts an event, but when not applicable pass in `undefined`. 2) pass `true` if pages should reset to page 1 e.g. if items have been deleted or filtered and pagination has changed (or pass `false`) 3) See below for `changeStateOptions`</td><td>This queues a debounced live update. If other events in a short period of time also queue an update, only the last will run. This function can be useful in a situation where a user-interaction changes the data in the database but does not alter any filters, and you wish to show the updated data e.g. as a callback function to a Siteglide eCommerce function.</td></tr></tbody></table><p>Example of setSortHTML method:</p><pre class="language-js"><code class="lang-js">instance.setSortHTML({
  unsorted: `&#x3C;bold>Sort ASC&#x3C;/bold>`,
  asc: `&#x3C;bold>Sort DESC&#x3C;/bold>`,
  desc: `&#x3C;bold>Sort ASC&#x3C;/bold>`
});
</code></pre><p>changeStateOptions</p><ul><li>onlyUpdateComponent allows you fine control over which components should re-render on this update.</li></ul><p>Example of changeStateOptions:</p><pre class="language-js"><code class="lang-js">instance.changeStateTrailingDebounce(undefined,false,{
  onlyUpdateComponent: ['a','b']
})
</code></pre><pre class="language-liquid"><code class="lang-liquid">&#x3C;div data-sg-live-update-component="a">
  //Will re-render this time
&#x3C;/div>
&#x3C;div data-sg-live-update-component="b">
  //Will not re-render this time
&#x3C;/div>
</code></pre><hr><p><strong>Events</strong></p><p>The module JavaScript defines and dispatches the following custom Events. You can watch for these using ordinary JavaScript event listeners. Alternatively, you can use the callback functions on initialisation to achieve the same goal, but note that the callback functions are more appropriate for one-off functions for a particular live-update, while the events below are useful for code which should run every time.</p><table data-full-width="true"><thead><tr><th>Target Element</th><th>event type</th><th>detail</th><th>description</th></tr></thead><tbody><tr><td>document</td><td>`"live_update_constructor_ready"`</td><td></td><td>After this event, you can run code which uses the Object constructor.</td></tr><tr><td>document</td><td>`"live_update_script_ready"`</td><td></td><td>This event fires when the asynchronous module JavaScript is ready and any data-attributes have been read and event listeners set. After this event, you can run code which uses the Object constructor, or access the `window.sgLiveUpdatesConfig` global variable containing references to each initiated `SitegurusLiveUpdate` object.</td></tr><tr><td>The element you passed as a parameter when initiating the Object</td><td>`"live_update_start"`</td><td><em>instance</em>- the Object created for this element, <em>defaultParams</em>- the parameters you passed in as defaults when initiating, <em>passedParams</em> - the parameters you passed in for this live-update, <em>params</em> - the resulting params of the request</td><td>This event is dispatched when the live-update is about to begin</td></tr><tr><td>The element you passed as a parameter when initiating the Object</td><td>`"live_update_end"`</td><td><em>instance</em>- the Object created for this element, <em>defaultParams</em>- the parameters you passed in as defaults when initiating, <em>passedParams</em> - the parameters you passed in for this live-update, <em>params</em> - the resulting params of the request,The total_entries returned, or if you passed the `collection` parameter, the full data returned from the WebApp</td><td>This event is dispatched when the live-update is about to end</td></tr></tbody></table><p><strong>Liquid Includes and Functions</strong></p><ul><li>See <a href="../sitebuilder-liquid-includes/pagination.md">Pagination Include</a> for settings specific to live-update data-attributes.</li></ul><p><strong>Endpoint Logic Reference</strong></p><p><em>This Section is included to provide useful information to advanced users and assist with troubleshooting. It may not be relevant to all users.</em></p><p>After the GET Request is sent with all of your chosen parameters, the context in which the new re-render of the Liquid is output is modified in the following ways:</p><ol><li>The Siteglide Constants Liquid tag is run, unless the special <code>sg_skip_siteglide_constants</code> URL parameter is passed in. You can optionally experiment with this to improve server response time if the content you use does not require it.</li><li>The tag is given the Siteglide <code>use_search</code> and <code>use_adv_search</code> parameters set to 'true' automatically. This means that any URL parameters described in this set of documents will be allowed to manipulate the filtering <a href="../../../webapps/layouts/searching-advanced-filtering.md">Filtering</a> &#x26; <a href="../../../webapps/layouts/searching-by-keyword.md">Searching</a>.</li><li>The <code>{{context.params}}</code> variables relating to the URL of the endpoint page are overwritten with those of the referring Page. This is to prevent any discrepancies in Layouts using them. Note we do not currently overwrite the <code>{{context.location}}</code> or <code>{{context.headers}}</code> objects, though future versions of this API might add an option to do this if requested.</li><li>There is no way to dynamically change the <code>layout</code> or the module/webapp <code>id</code> parameter- these are ignored. See "Thinking about Security".</li><li>The following params <code>range_lt</code>, <code>range_lte</code>, <code>range_gt</code> and <code>range_gte</code> are inspected. If they contain a date format which includes a dash <code>-</code> we convert them to the Unix timestamp which Siteglide expects and context.params is overwritten to reflect the new format. This allows you to skip the step of converting them in JavaScript from the value of a standard HTML field.</li><li>If the layout is a webapp layout and the <code>type</code> param is not set to "detail", we will add the <code>use_wrapper: 'true'</code> parameter to the Liquid tag. This means we only support WebApp list layouts with wrappers, as this allows them to be output self-contained. If you need to migrate an existing WebApp Layout to use a wrapper, you can see the differences here: <a href="../../../webapps/layouts/webapp-list-layout.md#nNjER">WebApp List Layouts</a></li><li>Any custom parameters you wish to send over you can. These can of course be accessed in the logic of the layout itself under <code>{{context.params}}</code>.</li><li>The URL parameters in the table above are read and, if necessary, turned into variables which are passed directly into the Liquid tag as Siteglide parameters.</li></ol><hr><h4 id="using-the-javascript-initialisation">Using the JavaScript Initialisation</h4><p><strong>Constructor Arguments</strong></p><p>The following arguments can be passed into the options Object as key:value pairs when initiating the <code>new SitegurusLiveUpdate</code> constructor.</p><p>e.g.</p><pre class="language-javascript"><code class="lang-javascript">const instance = new SitegurusLiveUpdate({
  defaultParams: {per_page: '20'}
});
</code></pre><table data-full-width="true"><thead><tr><th>parameter</th><th>required</th><th>type</th><th>example</th><th>notes</th></tr></thead><tbody><tr><td>element</td><td>required</td><td>element</td><td>`document.querySelector('#elementID')`</td><td>This needs to be the main DOM element that represents the outermost element rendered by your Siteglide Liquid tag. Note by default, the whole component will live-update, but you can change this by defining components within it.</td></tr><tr><td>public_key</td><td>required</td><td>String</td><td>`'some_public_key'`</td><td>See Initialising with the Object Constructor in JavaScript</td></tr><tr><td>liveUpdateComponents</td><td>optional</td><td>Array of elements</td><td>`Array.from(sectionEl.querySelectorAll('[data-sg-live-update-component]'))`</td><td>Use this to define which areas of your layout you wish to live-update. Any areas outside of these will not live-update and will maintain state and focus during a live-update. If you do not pass a value here, the whle initiated element will live-update instead.</td></tr><tr><td>defaultParams</td><td>optional</td><td>Object</td><td>`{per_page: '2', pagination_layout: 'default', item_ids: ['1','2']}` translates to `?per_page=2&#x26;pagination_layout=default&#x26;item_ids=1,2`</td><td>Any params passed in at a later stage via form controls (using data-attributes) or as parameters on the liveUpdate method will overwrite the defaultParams.</td></tr><tr><td>suspenseHTML</td><td>optional</td><td>HTML String</td><td>`'&#x3C;div>Loading...&#x3C;/div>'`</td><td>This HTML replace components' InnerHTML during a live-update. The component element itself remains in the DOM at this point. After live-update, the new content will replace the component so the HTML will not persist after that point.</td></tr><tr><td>suspenseCSSClassList</td><td>optional</td><td>Space-separated list of classes</td><td>`'class1 class2'`</td><td>These classes will be added to the component element during a live-update. After live-update, the new content will replace the component so the classes will not persist after that point.</td></tr><tr><td>autoEventListeners</td><td>optional</td><td>Boolean</td><td>`true`</td><td>Default is false. You can set this to true to use the functionality of the data-attribute method while actually initiating with the programatic method.</td></tr><tr><td>sortHTML</td><td>optional</td><td>object</td><td>`{unsorted: '&#x3C;span>&#x3C;/span>', asc: '&#x3C;span>&#x3C;/span>', desc: '&#x3C;span>&#x3C;/span>'}`</td><td>See the `.setSortHTML()` method for details. Default value contains an SVG icon for each state.</td></tr></tbody></table></td><td></td></tr><tr><td>parameter</td><td>notes</td><td></td><td></td><td></td></tr><tr><td>`item_ids`</td><td>If using data-attributes, we'll automatically send these in comma-seperated format.</td><td></td><td></td><td></td></tr><tr><td>`category_ids`</td><td>If using data-attributes, we'll automatically send these in comma-seperated format.</td><td></td><td></td><td></td></tr><tr><td>`show_all_sub_items`</td><td></td><td></td><td></td><td></td></tr><tr><td>`per_page`</td><td></td><td></td><td></td><td></td></tr><tr><td>`show_pagination`</td><td></td><td></td><td></td><td></td></tr><tr><td>`ignore_pagination`</td><td></td><td></td><td></td><td></td></tr><tr><td>`sort_type`</td><td></td><td></td><td></td><td></td></tr><tr><td>`sort_order`</td><td></td><td></td><td></td><td></td></tr><tr><td>`type`</td><td></td><td></td><td></td><td></td></tr><tr><td>`pagination_layout`</td><td></td><td></td><td></td><td></td></tr><tr><td>`datasource`</td><td></td><td></td><td></td><td></td></tr><tr><td>`datasource_fields_by_name`</td><td></td><td></td><td></td><td></td></tr><tr><td>`datasource_fields_by_id`</td><td></td><td></td><td></td><td></td></tr><tr><td>`collection`</td><td>This parameter will only work if `collection: 'true'` is also set on the public_key generating Liquid function tag; this is to prevent malicious users from being allowed to access raw data by default, without the layer of the server defining what they should and should not access. Note however that if you do allow this, the data will be viewable in the browser, so it must not be sensitive. If set to 'true' instead of returning HTML, we'll return the raw data from the collection. The data will be available in the details of the `live_update_end` custom event on the initiated element and in the parameters of the `onAfterLiveUpdate` callback function. The DOM will not be directly modified.</td><td></td><td></td><td></td></tr><tr><td>`creator_id`</td><td>If your users have permission to access webapp/ module items they did not personally create on the Front End, you can use this parameter dynamically as normal to filter. However, if you are using this parameter to prevent users from accessing items which do not belong to them and do not wish them to be able to change this in client-side code, you can make this a sensitive parameter by adding the same parameter to the `live_update_params_encode` function. If set against the function, the parameter can't be overridden.</td><td></td><td></td><td></td></tr><tr><td>`page`</td><td></td><td></td><td></td><td></td></tr><tr><td>`use_default_properties`</td><td></td><td></td><td></td><td></td></tr><tr><td>`range_field`</td><td>Coming soon in 4.8.2</td><td></td><td></td><td></td></tr><tr><td>`range_lt`</td><td></td><td></td><td></td><td></td></tr><tr><td>`range_lte`</td><td></td><td></td><td></td><td></td></tr><tr><td>`range_gt`</td><td></td><td></td><td></td><td></td></tr><tr><td>`range_gte`</td><td></td><td></td><td></td><td></td></tr><tr><td>`use_location_search`</td><td>Unlike `use_search` and `use_adv_search`, this is not set to `'true'` by default and must be set by the developer.</td><td></td><td></td><td></td></tr><tr><td>`longlat`</td><td></td><td></td><td></td><td></td></tr><tr><td>`distance`</td><td></td><td></td><td></td><td></td></tr><tr><td>`marketplace`</td><td>Required if this is a layout for a module downloaded from the Siteglide marketplace.</td><td></td><td></td><td></td></tr><tr><td>`cache`</td><td>Using this as a default parameter could significantly boost performance, but test carefully as the feature is presently in beta.</td><td></td><td></td><td></td></tr><tr><td>parameter</td><td>notes</td><td></td><td></td><td></td></tr><tr><td>`sg_skip_siteglide_constants`</td><td>Some layouts don't require the Siteglide constants tag to be rendered. You can optionally use this to skip it and improve server response time. Especiually useful if the site has a lot of categories but your layout doesn't use them.</td><td></td><td></td><td></td></tr><tr><td>Method</td><td>Parameters</td><td>Notes</td><td></td><td></td></tr><tr><td>`instance.liveUpdate(params,onBeforeLiveUpdate,onAfterLiveUpdate,changeStateOptions)`</td><td>1) `params` - Object - Pass in an object containing the key value pairs you'd like to be added to the GET request. 2) `onBeforeLiveUpdate` - Function - optional - callback function to run before update 3) `onAfterLiveUpdate` - Function - optional - Callback function to run after update. 4) See below for changeStateOptions</td><td>Params will override any default params, if they have the same key. The callback functions are especially suitable if you need any one-time side effects. If you need a callback function for every update, we recommend using events instead.</td><td></td><td></td></tr><tr><td>`instance.setSuspenseHTML('&#x3C;div>loading&#x3C;/div>')`</td><td>1) Pass in an HTML String.</td><td>We recommend using template literals. When live-updating begins, this HTML will be inserted into the area which is being live-updated. When the live-updating ends, the HTML will be replaced with the live-updated component HTML. This can also be set when using the constructor.</td><td></td><td></td></tr><tr><td>`instance.setSuspenseCSSClassList('class1 class2')`</td><td>1) ClassList space-separated</td><td>Sets CSS classes on each live-updating component and then removes them once the live-updating is complete. If no components are used, the classes are toggled on the main initiated element. As well as allowing you to change style directly, you can also use it to position suspense HTML within the container. This can also be set when using the constructor.</td><td></td><td></td></tr><tr><td>`instance.setModifyHistory({enabled: true, includeHiddenFields: false})`</td><td>1) Object</td><td>Pass in an object with an `enabled` boolean and `includehiddenFields` boolean. This changes the behaviour of each following liveUpdate so that it will update the URL query parameters without reloading the page. Useful for creating shareable links.</td><td></td><td></td></tr><tr><td>`instance.setSortHTML({unsorted: '', asc: '', desc: ''})`</td><td>1) object</td><td>Pass in an object containing an HTML string (recommend template literals) for each of the three button states.</td><td></td><td></td></tr><tr><td>`deprecated instance.setDefaultParams(object)`</td><td>1) object</td><td>Pass in an object containing the key: value pairs of parameters you wish to use as default params to fully replace existing defaultParams. Use of this is not encouraged. Use `mergeUpdateParams` instead.</td><td></td><td></td></tr><tr><td>`instance.mergeDefaultParams(object)`</td><td>1) object</td><td>Pass in an object containing the key: value pairs of parameters you wish to use as default params. This preserves any existing defaultParams, unless one of your properties matches them, in which case your property will be set.</td><td></td><td></td></tr><tr><td>`instance.changeStateTrailingDebounce(event,resetPages = false,changeStateOptions)`</td><td>1) Normally accepts an event, but when not applicable pass in `undefined`. 2) pass `true` if pages should reset to page 1 e.g. if items have been deleted or filtered and pagination has changed (or pass `false`) 3) See below for `changeStateOptions`</td><td>This queues a debounced live update. If other events in a short period of time also queue an update, only the last will run. This function can be useful in a situation where a user-interaction changes the data in the database but does not alter any filters, and you wish to show the updated data e.g. as a callback function to a Siteglide eCommerce function.</td><td></td><td></td></tr><tr><td>Target Element</td><td>event type</td><td>detail</td><td>description</td><td></td></tr><tr><td>document</td><td>`"live_update_constructor_ready"`</td><td></td><td>After this event, you can run code which uses the Object constructor.</td><td></td></tr><tr><td>document</td><td>`"live_update_script_ready"`</td><td></td><td>This event fires when the asynchronous module JavaScript is ready and any data-attributes have been read and event listeners set. After this event, you can run code which uses the Object constructor, or access the `window.sgLiveUpdatesConfig` global variable containing references to each initiated `SitegurusLiveUpdate` object.</td><td></td></tr><tr><td>The element you passed as a parameter when initiating the Object</td><td>`"live_update_start"`</td><td><em>instance</em>- the Object created for this element, <em>defaultParams</em>- the parameters you passed in as defaults when initiating, <em>passedParams</em> - the parameters you passed in for this live-update, <em>params</em> - the resulting params of the request</td><td>This event is dispatched when the live-update is about to begin</td><td></td></tr><tr><td>The element you passed as a parameter when initiating the Object</td><td>`"live_update_end"`</td><td><em>instance</em>- the Object created for this element, <em>defaultParams</em>- the parameters you passed in as defaults when initiating, <em>passedParams</em> - the parameters you passed in for this live-update, <em>params</em> - the resulting params of the request,The total_entries returned, or if you passed the `collection` parameter, the full data returned from the WebApp</td><td>This event is dispatched when the live-update is about to end</td><td></td></tr><tr><td>parameter</td><td>required</td><td>type</td><td>example</td><td>notes</td></tr><tr><td>element</td><td>required</td><td>element</td><td>`document.querySelector('#elementID')`</td><td>This needs to be the main DOM element that represents the outermost element rendered by your Siteglide Liquid tag. Note by default, the whole component will live-update, but you can change this by defining components within it.</td></tr><tr><td>public_key</td><td>required</td><td>String</td><td>`'some_public_key'`</td><td>See Initialising with the Object Constructor in JavaScript</td></tr><tr><td>liveUpdateComponents</td><td>optional</td><td>Array of elements</td><td>`Array.from(sectionEl.querySelectorAll('[data-sg-live-update-component]'))`</td><td>Use this to define which areas of your layout you wish to live-update. Any areas outside of these will not live-update and will maintain state and focus during a live-update. If you do not pass a value here, the whle initiated element will live-update instead.</td></tr><tr><td>defaultParams</td><td>optional</td><td>Object</td><td>`{per_page: '2', pagination_layout: 'default', item_ids: ['1','2']}` translates to `?per_page=2&#x26;pagination_layout=default&#x26;item_ids=1,2`</td><td>Any params passed in at a later stage via form controls (using data-attributes) or as parameters on the liveUpdate method will overwrite the defaultParams.</td></tr><tr><td>suspenseHTML</td><td>optional</td><td>HTML String</td><td>`'&#x3C;div>Loading...&#x3C;/div>'`</td><td>This HTML replace components' InnerHTML during a live-update. The component element itself remains in the DOM at this point. After live-update, the new content will replace the component so the HTML will not persist after that point.</td></tr><tr><td>suspenseCSSClassList</td><td>optional</td><td>Space-separated list of classes</td><td>`'class1 class2'`</td><td>These classes will be added to the component element during a live-update. After live-update, the new content will replace the component so the classes will not persist after that point.</td></tr><tr><td>autoEventListeners</td><td>optional</td><td>Boolean</td><td>`true`</td><td>Default is false. You can set this to true to use the functionality of the data-attribute method while actually initiating with the programatic method.</td></tr><tr><td>sortHTML</td><td>optional</td><td>object</td><td>`{unsorted: '&#x3C;span>&#x3C;/span>', asc: '&#x3C;span>&#x3C;/span>', desc: '&#x3C;span>&#x3C;/span>'}`</td><td>See the `.setSortHTML()` method for details. Default value contains an SVG icon for each state.</td></tr></tbody></table>
